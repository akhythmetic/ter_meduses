---
title: "analyse_pulsation_trajectoire"
author: "louati"
date: "2025-11-26"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Analyse pulsation et trajectoire

## A-Generation de donn√©e en attendant la donn√©e des collegues

```{r}
# Nombre de m√©duses et de frames
n_meduses <- 5    # par exemple 5 m√©duses
n_frames  <- 100  # 100 frames
```

```{r}
# Colonne frame : r√©p√®te 1,2,...,n_frames pour chaque m√©duse
df <- data.frame(
  frame = rep(1:n_frames, times = n_meduses)
)
```

```{r}
# Colonne id_meduse : 1,1,...,1 (n_frames fois), puis 2,2,...,2, etc.
df$id_meduse <- rep(1:n_meduses, each = n_frames)
```

```{r}
head(df)
table(df$id_meduse)
```

```{r}
# Colonnes x et y : positions al√©atoires pour l'instant
largeur_image  <- 1920
hauteur_image  <- 1080

set.seed(123)  # pour avoir les m√™mes valeurs √† chaque ex√©cution

df$x <- runif(nrow(df), min = 0, max = largeur_image)
df$y <- runif(nrow(df), min = 0, max = hauteur_image)
```

```{r}
# Colonne area : superficie de la m√©duse (pixels¬≤)
set.seed(123)  # pour reproductibilit√©

# ------------------------------------------------------------
# Param√®tres "physiques" de la vid√©o / pulsations
# ------------------------------------------------------------
fps <- 6           # nombre de frames par seconde
# Fr√©quence de pulsation en pulsations par seconde.
# 0.5 puls/s => 1 pulsation toutes les 2 secondes
# 1.5 puls/s => 1 pulsation toutes les 2/3 de seconde
min_freq <- 0.5    # borne basse : 0.5 pulsation / seconde
max_freq <- 1.5    # borne haute : 1.5 pulsation / seconde
freq_sd <- 0.05   # √©cart-type du bruit de fr√©quence : plus petit => plus lisse
```

```{r}

# ------------------------------------------------------------
# Param√®tres par m√©duse : taille de base et amplitude
# ------------------------------------------------------------
# baseline_by_meduse : taille moyenne (ouverte/contract√©e au milieu)
# baseline_by_meduse = une valeur moyenne par m√©duse.
baseline_by_meduse <- rlnorm(
  n_meduses,
  meanlog = log(500),  # moyenne autour de 500
  sdlog   = 0.2        # faible dispersion -> tailles assez stables entre m√©duses
)
baseline_by_meduse
```

```{r}
# amp_rel_by_meduse : amplitude relative (20% √† 40% de la taille de base)
# C‚Äôest la variation entre la taille moyenne et le pic (ou le creux).
amp_rel_by_meduse <- runif(
  n_meduses,
  min = 0.2,   # 20% de variation
  max = 0.4    # 40% de variation
)
amp_rel_by_meduse
```

```{r}
# Cette ligne sert √† donner √† chaque m√©duse un ‚Äúretard/avance‚Äù diff√©rent dans sa pulsation pour qu‚Äôelles ne pulsent pas toutes ensemble.
phase_init <- runif(n_meduses, min = 0, max = 2*pi)
phase_init
```

```{r}

# ------------------------------------------------------------
# Construction de la colonne area avec pulsations
# ------------------------------------------------------------
df$area <- NA_real_
head(df$area)
```

```{r}
for (i in 1:n_meduses) {
  # indices des lignes correspondant √† la m√©duse i
  
  #vecteur qui ressence tous les frame o√π la meduse i apparait
  idx <- which(df$id_meduse == i) 
  #nombre de frame sur sur les quel la meduse i apparait
  n_i <- length(idx) 
  
  baseline <- baseline_by_meduse[i]   # taille moyenne de cette m√©duse i
  amp_rel  <- amp_rel_by_meduse[i]    # amplitude relative de la meduse i
  phi      <- phase_init[i]           # phase courante de la meduse i
  
  area_i <- numeric(n_i) # Vecteur vide pour stocker toutes les surfaces
   
   # üîπ 1) fr√©quence initiale pour cette m√©duse
  freq_k <- runif(1, min = min_freq, max = max_freq)
  
  for (k in 1:n_i) {
    # üîπ 2) petite variation autour de la fr√©quence pr√©c√©dente
    freq_k <- freq_k + rnorm(1, mean = 0, sd = freq_sd)
    
    # üîπ 3) on recadre pour rester entre min_freq et max_freq
    freq_k <- max(min_freq, min(max_freq, freq_k))
    
    # üîπ 4) on avance dans la phase en fonction de la fr√©quence
    phi <- phi + 2 * pi * (freq_k / fps)
    
    # üîπ 5) surface sinusoidale
    area_theo <- baseline * (1 + amp_rel * sin(phi))
    
    # üîπ 6) petit bruit d‚Äôobservation
    bruit <- rnorm(1, mean = 0, sd = baseline * 0.05)
    
    area_i[k] <- area_theo + bruit
  }
  
  # On √©vite les surfaces trop petites
  area_i <- pmax(area_i, baseline * 0.3)
  
  df$area[idx] <- area_i
}
```

### Resultat de la g√©n√©ration

```{r}
head(df)
str(df)
```

```{r}
meduses <- unique(df$id_meduse)

par(mar = c(4, 4, 2, 1))   # r√©duit les marges

# Pr√©parer une grille de plots : 1 ligne par m√©duse
par(mfrow = c(length(meduses), 1))

for (id in meduses) {
  plot(df$frame[df$id_meduse == id],
       df$area[df$id_meduse == id],
       type = "l",
       xlab = paste("Frame (m√©duse", id, ")"),
       ylab = "Surface",
       main = paste("Pulsation de la m√©duse", id))
}

```

## B- Calcule de la frequence pour chaque meduse √† chaque frame

```{r}
library(pracma)  # contient la fonction findpeaks()
```

```{r}
## On trie le dataframe par id_meduse puis par frame
## (pour avoir les images dans l'ordre du temps pour chaque m√©duse)
df <- df[order(df$id_meduse, df$frame), ]
head(df)
```

```{r}
## On cr√©e une nouvelle colonne pour stocker la fr√©quence
df$freq <- NA_real_
```

```{r}
## liste des m√©duses pr√©sentes dans le df
ids <- unique(df$id_meduse)

for (id in ids) {
  
  ## indices des lignes correspondant √† cette m√©duse
  idx <- which(df$id_meduse == id)
  
  ## sous-dataframe pour cette m√©duse uniquement
  d <- df[idx, ]
  
  ## vecteur d'aire au cours du temps (pour cette m√©duse)
  a <- d$area
  
  ## ------------ 1) D√âTECTION DES PICS D'AREA ------------
  ## findpeaks renvoie une matrice :
  ## colonne 2 = position du pic dans le vecteur 'a'
  #on utilise que la 2e colonne position du pic correspondant √† l'index dans le vecteur area
  pk <- findpeaks(a, sortstr = FALSE) 
  
  ## Si aucun pic, ou moins de 2 pics -> impossible de d√©finir une fr√©quence
  if (is.null(pk) || nrow(pk) < 2) {
    next  # on laisse freq = NA pour cette m√©duse et on passe √† la suivante
  }
  
  peak_indices <- pk[, 2]                 # indices des pics dans 'a'
  peak_frames  <- d$frame[peak_indices]   # num√©ros de frame o√π il y a un pic
  
  ## ------------ 2) P√âRIODE ET FR√âQUENCE ENTRE LES PICS ------------
  ## p√©riode (en nombre d'images) entre deux pics successifs
  periods <- diff(peak_frames)            # length = nb_pics - 1
  
  ## fr√©quence (en oscillations par image)
  freqs <- 1 / periods
  
  ## ------------ 3) FR√âQUENCE POUR CHAQUE IMAGE ------------
  ## On a une fr√©quence pour chaque intervalle entre pics.
  ## On interpole ces fr√©quences pour obtenir une valeur √† chaque frame.
  ## approx() fait une interpolation lin√©aire :
  ##  - x  : frames o√π la fr√©quence est connue
  ##  - y  : fr√©quence connue √† ces frames
  ##  - xout : toutes les frames de la m√©duse
  ##  - rule = 2 : on prolonge la premi√®re et la derni√®re valeur en dehors
  approx_out <- approx(
    #approx() prend les fr√©quences connues au niveau des pics d‚Äôarriv√©e et les √©tale     sur toutes les images interm√©diaires, pour te donner une fr√©quence √† chaque     frame. 
    x   = peak_frames[-1],  # on associe chaque freq √† la frame du 2e pic
    y   = freqs,
    xout = d$frame,
    rule = 2
  )
  
  ## On remet ces fr√©quences dans le df d'origine
  df$freq[idx] <- approx_out$y
}

```

```{r}
df
```

```{r}
library(ggplot2)

ggplot(df, aes(x = frame, y = freq)) +
  geom_line() +
  facet_wrap(~ id_meduse) +
  labs(
    x = "Frame",
    y = "Fr√©quence",
    title = "Fr√©quence d'oscillation par m√©duse"
  )
```

## C- Calcule des vecteurs directionnels

```{r}
# On s'assure que le tableau est bien tri√©
df <- df[order(df$id_meduse, df$frame), ]

# On cr√©e les deux colonnes dans df
df$dx <- NA_real_
df$dy <- NA_real_

# Liste de toutes les m√©duses
ids <- unique(df$id_meduse)

for (id in ids) {
  
  # lignes appartenant √† cette m√©duse
  idx <- which(df$id_meduse == id)
  d   <- df[idx, ]
  
  # Calcul du vecteur de direction
  dx <- c(NA, diff(d$x))   # NA pour la 1√®re frame (pas de frame pr√©c√©dente)
  dy <- c(NA, diff(d$y))
  
  # On remet dans df
  df$dx[idx] <- dx
  df$dy[idx] <- dy
}
```

```{r}
df
```

## D- Calcule de la vitesse par frame

```{r}
df$vitesse <- sqrt(df$dx^2 + df$dy^2)
df
```

### Vitesse moyenne de chaque meduse en Pixel/frame

```{r}
tapply(df$vitesse, df$id_meduse, mean, na.rm = TRUE)
```

## E- PCA

```{r}
dfQuanti <- df[, c("id_meduse","x", "y", "area", "freq", "dx", "dy", "vitesse")]
dfQuanti
```

```{r}
#y a t-il des variables manquantes ?  
sum(is.na(dfQuanti))
```

```{r}
df[!complete.cases(df), ]
```

```{r}
str(df)
```
